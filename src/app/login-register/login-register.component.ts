import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { HttpClient } from '@angular/common/http';
import { throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { KeyManager } from '../domain/security/key-manager';

@Component({
  selector: 'app-login-register',
  templateUrl: './login-register.component.html',
  styleUrls: ['./login-register.component.scss']
})
export class LoginRegisterComponent implements OnInit {

  isLoggingIn: boolean = true;
  isRegisterError: boolean = false;
  isLoginError: boolean = false;
  username: string = '';
  password: string = '';

  manager: KeyManager = new KeyManager();

  constructor(private route: ActivatedRoute, private router: Router, private http: HttpClient) { }

  ngOnInit(): void {
    console.log(this.route.snapshot.paramMap);
    let mode = this.route.snapshot.paramMap.get('mode');
    if (mode === 'register') {
      this.isLoggingIn = false;
    }
  }

  /*
    TODO:

    Login
      Enter username and password √
      Load keys from files
      Get session ticket to add to all requests √

    Register
      Enter username and password
      Create key and send to server
      -> Login

    Encryption/Decryption
      Store RSA private key in a file and retrieve it to decrypt messages.
      Store RSA public key in a file to sign messages.
      Encrypt RSA storage files with a password generated by the user's password.
      Sender encrypts and signs message using RSA keys.
      Server and Receiver verify tag of messages and the Sender.

    Home, ConversationView
      Require valid (matching) session key in all requests
  */

//let ciphertext = manager.encrypt(manager.publicKey, 'hello world');
//manager.decrypt(manager.privateKey, ciphertext);

//let passwordHash = manager.hash(this.password);

  async login() {
    /*
      Enter username √
      Enter password √
      Click Submit √
      Send username and password hash to server √
      Server checks for existence of username √
      Server checks password hash against the existing user with that username √
      Server generates random session key for the user, returns it, and tells the user it is logged in
      Client saves session key and reads public and private keys from files into local storage. Also save current username in local storage.
      Client navigates to the home page and sees a list of conversations for the current user
    */
  
    let passwordHash = await KeyManager.hash(this.password);
    console.log('hash:', passwordHash);
    console.log('->', passwordHash);
    let user = {username: this.username, passwordHash: passwordHash};
    console.log(user);
    this.http.post('https://localhost:1443/users/login', user, {responseType: 'json'})
              .pipe(catchError(this.handleError(this.loginError)))
              .subscribe(result => {
              console.log(`result:`, result);
                this.onSuccessfulLogin(result);
              });
  }

  loginError = () => {
    this.isLoginError = true;
  }

  onSuccessfulLogin(result) {
    alert('logged in');
  }

  async register() {
    this.isRegisterError = false;
    let passwordHash = await KeyManager.hash(this.password);
    console.log('hash:', passwordHash);
    await this.manager.generateKeys();

    let user = {username: this.username, passwordHash: passwordHash, key: this.manager.publicKey};
    console.log(user);
    this.http.post('https://localhost:1443/users/register', user, {responseType: 'text'})
             .pipe(catchError(this.handleError(this.registerError)))
             .subscribe(result => {
               console.log(`result:`, result);
               this.onSuccessfulRegistration(); // TODO: Store the keys in a file...
             });
  }

  registerError = () => {
    this.isRegisterError = true;
  }

  onSuccessfulRegistration() {
    this.router.navigateByUrl('connect/login');
    this.isLoggingIn = true;
  }

  createAccount(): void {
    this.router.navigateByUrl('connect/register');
    this.isLoggingIn = false;
    this.isLoginError = false;
    this.isRegisterError = false;
  }

  handleError = callback => function(error) {
    callback();
    let errorMessage = '';
    if (error.error instanceof ErrorEvent) {
        // client-side error
        errorMessage = `Error: ${error.error.message}`;
    } else {
        // server-side error
        errorMessage = `Error Code: ${error.status}\nMessage: ${error.message}`;
    }
    console.log(errorMessage);
    return throwError(errorMessage);
  }

}
